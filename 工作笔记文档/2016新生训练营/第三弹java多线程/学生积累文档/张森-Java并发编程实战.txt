# Java并发编程实战

## 1. 线程管理

### 1. Java中创建线程的方式：
    1.1 继承Thread类，并且覆盖run()方法；
    1.2 创建一个实现Runnable接口的类。使用带参数的Thread构造器来创建Thread对象，这个参数是实现Runnable接口的类的一个对象。这种方式创建的类，只有在调用它的start()方法时，才会创建一个新的执行线程。
### 2. 线程信息的获取和设置：
    2.1 Thread类中用于保存信息的属性有：
        ID：线程的唯一标识符；
        Name：线程名称；
        Priority：线程对象的优先级（从1到10,1是最低优先级，10是最高优先级）；
        Status：线程的状态。包括6种，分别为：new、runnable、blocked、waiting、time waiting和terminated。
### 4. 线程的中断
    4.1 Java含有不止一个执行线程时，程序运行结束的标识是
        1）所有的非守护线程运行结束；
        2）或者，其中一个线程调用了System.exit()方法；
    4.2 Java中线程中断的方法，调用interrupt()方法；
    4.3 使用isInterrupted可以判断线程是否中断；Thread类的静态方法interrupted()也可以判断线程是否中断，只是调用此方法后，它会清空线程中断的状态（设置interrupted属性为false）；
    
### 6. 线程的休眠和恢复
    6.1 线程休眠时不占用计算机的任何资源；
    6.2 线程休眠可以使用Thread类的静态方法sleep(long millis)，该方法接受的参数单位为毫秒数；
        线程休眠也可以调用TimeUnit枚举类的sleep(long seconds),该方法接受的参数单位为秒；
        用法示例（休眠一秒）：
        TimeUnit.SECONDS.sleep(1);

### 7. 等待线程的终止
    7.1 多个线程同时执行时，如果要等到某一个线程执行完毕后再执行，可以使用join()方法；
    7.2 当一个线程对象的join()方法被调用时，调用它的线程将被挂起，知道这个线程对象完成它的任务；
    7.3 join()方法还有另外两种形式，分别是join(long milliseconds)和join(long milliseconds, long nanos);
        对于join(long milliseconds)，如果thread1中有这样的代码thread2.join(1000)，thread1将挂起运行，知道满足两个条件之一：
        - thread2运行完成；
        - 时钟已经过去1000毫秒。
        
### 8. 守护线程的创建和运行
    8.1 守护（Daemon）线程优先级很低，当应用程序中没有其它的线程运行时，守护线程才会运行。守护线程时程序中唯一运行的线程时，守护线程执行结束后，JVM也就结束了这个程序；
    8.2 守护线程通常用来作为同一程序中普通线程的服务提供者；
    8.3 将线程设置为守护线程的方法：
        1）在线程中调用setDaemon(true)方法；例如
        public CleanerTask(Deque<Event> deque){
            this.deque = deque;
            setDaemon(true);
        }
        注：setDaemon()方法只能在start()方法被调用之前设置，一旦线程开始运行，将不能再修改守护状态。
        
    问题：
    1）此小节中的例子运行时出现问题，使用run时控制台无输出，debug时才会输出？
    2）为何队列中的元素个数不会减少为0？
    
### 9. 线程中不可控异常的处理     
    9.1 Java中有两种异常：
        a) 非运行时异常（Checked Exception）：必须在方法声明的throws语句中指定，或在方法体重捕获，如IOException。
        b) 运行时异常（Unchecked Exception）:不必在方法声明中指定，也不需要在方法体中捕获，例如NumberFormatException。
        
    9.2 线程中异常处理特殊之处：run()方法不支持throws语句。因此run()方法抛出非运行异常时，需要捕获并进行处理；当运行时异常从run()方法中抛出时，默认行为是在控制台输出堆栈记录并且退出程序。
    9.3 Java中捕获和处理线程对象中的运行时异常的一种机制：
        a) 实现用来处理运行时异常的类，这个类实现UncaughtExcepionHandler接口并实现uncaughtException()方法
        b) 在线程启动前，使用线程对象调用setUncaughtExceptionHandler()方法设置线程的运行时异常处理器，like this：
            Task task = new Task();
            Thread thread = new Thread(task);
            thread.setUncaughtExceptionHandler(new Exceptionhandler());
            thread.start();
    9.4 Thread类中有一个静态方法setDefaultUncaughtExceptionHandler()可以处理未捕获到的异常，这个方法在应用程序中为所有的线程对象创建了一个异常处理器。（是否就是9.5中所说的默认的未捕获异常处理器？？）
    9.5 线程中抛出一个未捕获到的异常时，JVM会为异常寻找一下三种可能的处理器，先后次序为：
        a) 线程对象的未捕获异常处理器；
        b) 线程对象所在的线程组的未捕获异常处理器
        c) 默认的异常未捕获异常处理器
        如果以上都没有，将在控制台中输出堆栈异常记录，并退出程序。
### 10. 线程局部变量的使用
    10.1 如果创建的对象实现了Runnable接口的类的实例，用它作为传入参数创建多个线程对象并启动这些线程，那么所有的线程将共享相同的属性。也就是说，如果一个线程改变了属性值，其它线程都会被这个改变影响；
    10.2 在某种情况下，对象的属性不需要被所有线程共享，这时可以使用“线程局部变量（Thread-Local Variable）”作为线程的属性值；like this：
    private static ThreadLocal<Date> startDate = new ThreadLocal<Date>() {
        protected Date initialValue() {
            return new Date();
        }
    }
    线程局部变量会为每一个线程都存储各自的属性值。







































