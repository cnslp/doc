# Effective Java学习笔记

## 第一章. 创建和销毁对象

### 1. 考虑用静态工厂方法代替构造器
    A. 静态工厂方法相较于构造器的优势在于：
    1.1 静态工厂方法有名称，可以准确描述返回的对象；
    1.2 不必在每次调用的时候都创建一个新的对象（当创建新对象的开销较大时，这项技术可以提高性能）；
    1.3 它可以返回原返回类型的任何子类型的对象；
    1.4 在创建参数化类型实例的时候，它们使代码变得更加简洁（对于JDK1.8，这一条优势已经不明显，
        因为调用参数化类的构造器，类型参数可以不用指明（JDK1.6中需要指明），如：
        Map<String, Object> list = new HashMap<String, Object>();
        可以写为：
        Map<String, Object> list = new HashMap<>();
        
    B. 静态工厂方法的一些惯例名称：
        valueOf: 类型转换方法，返回的实例与它的参数具有相同的值；
        of: valueOf的一种更为简洁的替代；
        getInstance: 返回的实例通过方法的参数来描述；对于Singleton来说，该方法没有参数，并返回唯一的实例；
        newInstance: newInstance能够确保返回的每个实例都与所有其他实例不同；
        getType: 像getInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型。
        newType: 像newInstance一样，但是在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型。
        
### 2. 遇到多个构造器参数时考虑用构建器
    2.1 对于包含多个成员变量的类，类的构造器可以使用“重叠构造器模式”，形式举例如下：
        public class User {
            private String name;
            private int age;
            private String phone;

            public User(String name) {
                this(name, 0);
            }
            
            public User(String name, int age) {
                this(name, age, "");
            }

            public User(String name, int age, String phone) {
                this.name = name;
                this.age = age;
                this.phone = phone;
            }
        }
        重叠构造器的缺点在于：当参数较多的时候，客户端调用时输入参数容易出错。
    
    2.2 遇到多个构造器参数的时候，还可以使用JavaBeans模式。即使用无参的构建器创建对象，
        然后使用成员变量的set方法对成员变量进行赋值；代码示例如下：
        
        User user = new User();
        user.setName("A");
        user.setAge(10);
        
        JavaBeans的缺点：构造过程被分到好几个调用中，在构造过程中JavaBean可能处于不一致的状态；
        试图使用处于不一致状态的对象，将会导致失败。同时，JavaBeans模式阻止了把类做成不可变的
        可能，我们需要付出额外的努力来确保它的线程安全。
        
    2.3 Builder模式--创建包含多个参数的对象。不直接生成想要的对象，而是让客户端利用所有必要的参数
        调用构造器，得到一个builder对象。然后客户端在builder对象上调用类似于setter的方法为类中的成
        员变量赋值。代码示例如下：
    
        public class User {
            private String name;
            private int age;
            private String phone;

            public static class Builder {
                private String name;
                private int age = 0;
                private String phone = "";

                public Builder(String name) {
                    this.name = name;
                }
                public Builder age(int age) {
                    this.age =age;
                    return this;
                }
                public Builder phone(String phone) {
                    this.phone = phone;
                    return this;
                }

                public User build() {
                    return new User(this);
                }
            }

            private User(Builder builder) {
                age = builder.age;
                phone = builder.phone;
            }

            public static void main(String[] args) {
                User user = new User.Builder("A").age(10).phone("119").build();
            }
        }
        **疑问**
        此处创建对象时为什么不会存在JavaBean模式中的不一致状态？？（毕竟JavaBean中的setter方法也可以按照builder
        模式中的进行改造，最后生成对象时可以有和builder一样的形式）
        
## 第八章. 通用程序设计

### 48. 使用BigDecimal进行精确计算
    48.1 float和double类型无法精确地表示小数（例如10的任何负数次幂），不适用于需要精确计算结果的场合（货币计算）；
        **例如**：System.out.println(1-9*0.1); //输出的是0.09999999999999998
    48.2 要进行精确计算，使用BigDecimal，然后基本的算术运算必须使用这个类中的方法，而不能使用"+,-"这些符号；另外
        需要注意的是，使用BigDecimal的构造器时，需要使用参数为字符串类型的，不然仍然达不到想要的效果；
        **代码示例如下**：
        //使用字符串作为参数
        BigDecimal _funds = new BigDecimal("1");
        BigDecimal _goods = new BigDecimal("0.9");
        System.out.println(_funds.subtract(_goods));  //输出 0.1
        //不使用字符串作为参数
        BigDecimal funds = new BigDecimal(1);
        BigDecimal goods = new BigDecimal(0.9);
        System.out.println(funds.subtract(goods));  //输出 0.09999999999999997779553950749686919152736663818359375
        //不使用字符串作为参数创建的对象可以进行**舍入控制**
        MathContext mathContext = new MathContext(4, RoundingMode.CEILING);
        System.out.println(_funds.subtract(_goods, mathContext));  //输出 0.1
        System.out.println(funds.subtract(goods, mathContext));  //输出 0.1000
        
        其中，RoundingMode枚举类总包括了8种舍入模式；
    48.3 当操作的数字小数点的位数比较固定时，所涉及的数值不太大时，可以使用int或者long类型进行计算，只需要额外使用
        一个数字保存小数点的位数即可；毕竟BigDecimal进行计算的性能没有java基本类型好；
        
### 49. 基本类型优于装箱基本类型
    49.1 Java的类型系统有两部分构成，基本类型（int、double和boolean）和引用类型（String, List）;
    49.2 Java每一个基本类型都有一个对应的引用类型，称作装箱基本类型（Integer、Double和Boolean）;
    49.3 Java基本类型和装箱基本类型之间的主要区别：
        a. 基本类型只有值，装箱基本类型则有与它们的值不同的同一性；两个装箱基本类型可以具有相同的值和不同的同一性；
        b. 基本类型只有功能完备的值，而装箱基本类型除了它对应的基本类型的所有功能值外，还有一个非功能值：null；
        c. 基本类型比装箱基本类型更节省时间和空间；
    49.4 查看一个例子，体会Java的自动装箱和拆箱；
        **说明**：比较器的compare方法返回的数值到底为负数、零还是正数，要取决于它的第一个参数是小于、等于还是大于它
        的第二个参数。
        Comparator<Integer> naturalOrder = new Comparator<Integer>(){
            public int compare(Integer first, Integer second) {
                return first < second ? -1 : (first == second ? 0 : 1);
            }
        };
        System.out.println(naturalOrder.compare(new Integer(4), new Integer(4))); //输出结果为 1
        出现上述结果的原因在于，执行表达式（first < second）时，被first和second引用的实例被自动拆箱，（4 < 4）结果为
        false；转而执行（first == second）时，它在对象引用上执行同一性比较，它们虽然值相同，但是引用的对象不同，因此
        （first == second）为false。
    49.5 在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型会自动拆箱；null对象引用被自动拆箱时，就会得到一个
        NullPointerException
        
        
        
        
    题目：三个线程A、B和C，利用线程的知识循环打印10次ABC

    public class MainClass {
        public static void main(String[] args) {
            ThreadLocal<Integer> initialCount = new ThreadLocal(){
                protected Integer initialValue(){
                    return 1;
                }
            };
            Print print = new Print(FlagEnum.A.getCode(), initialCount);
            Thread threadA = new Thread(new PrintA(print));
            Thread threadB = new Thread(new PrintB(print));
            Thread threadC = new Thread(new PrintC(print));

            threadA.start();
            threadB.start();
            threadC.start();
        }
    }
    //PrintA,PrintB和PrintC三个类结构相同，以PrintA进行举例：
    public class PrintA implements Runnable{
        private Print print;
        public PrintA(Print print) {
            this.print = print;
        }

        @Override
        public void run() {
            try {
                print.printChar(FlagEnum.A);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public class Print {
        private int flag;
        private ThreadLocal<Integer> printCount;
        private static final int MAX_PRINT_NUMS = 10;

        public Print(int flag, ThreadLocal<Integer> printCount) {
            this.flag = flag;
            this.printCount = printCount;
        }

        public synchronized void printChar(FlagEnum flagenum) throws InterruptedException {
            while (printCount.get() < MAX_PRINT_NUMS) {
                if (flag == flagenum.getCode()) {
                    System.out.print(flagenum.getName());
                    printCount.set(printCount.get() + 1);
                    notifyAll();
                    switch (flagenum) {
                        case A:
                            flag = FlagEnum.B.getCode();
                            break;
                        case B:
                            flag = FlagEnum.C.getCode();
                            break;
                        case C:
                            flag = FlagEnum.A.getCode();
                            break;
                    }
                }
                if (printCount.get() < MAX_PRINT_NUMS) {
                    wait();
                }
            }
        }
    }

    public enum FlagEnum {
        A(1, "A"), B(2, "B"), C(3, "C");
        private int code;
        private String name;

        FlagEnum(int code, String name) {
            this.code = code;
            this.name = name;
        }

        public int getCode() {
            return code;
        }

        public String getName() {
            return name;
        }
    }
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        